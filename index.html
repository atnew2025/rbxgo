<!--
╔══════════════════════════════════════════════════════════════════════════════╗
║  SHADOW CIPHER - Ultimate Luau Obfuscator                                    ║
║  Version: 3.2.0                                                              ║
║  Release Date: 2026-02-06                                                    ║
║  Official Website: https://luau.gkop.cc                                      ║
║  Copyright (c) 2026 Shadow Cipher Team. All rights reserved.                 ║
╚══════════════════════════════════════════════════════════════════════════════╝
-->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHADOW CIPHER - Luau Obfuscator</title>
    <!-- hCaptcha -->
    <script src="https://js.hcaptcha.com/1/api.js" async defer></script>
    <!-- SVG Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2300f5ff'/%3E%3Cstop offset='50%25' stop-color='%23bf00ff'/%3E%3Cstop offset='100%25' stop-color='%23ff00aa'/%3E%3C/linearGradient%3E%3C/defs%3E%3Ccircle cx='50' cy='50' r='45' fill='%230a0a0f' stroke='url(%23g)' stroke-width='3'/%3E%3Cpath d='M35 35 L50 25 L65 35 L65 50 L50 60 L35 50 Z' fill='none' stroke='url(%23g)' stroke-width='2'/%3E%3Ccircle cx='50' cy='42' r='8' fill='url(%23g)'/%3E%3Cpath d='M30 70 Q50 80 70 70' fill='none' stroke='url(%23g)' stroke-width='2'/%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --neon-cyan: #00f5ff;
            --neon-purple: #bf00ff;
            --neon-pink: #ff00aa;
            --neon-green: #00ff88;
            --dark-bg: #0a0a0f;
            --darker-bg: #050508;
            --card-bg: #12121a;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: var(--dark-bg);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        /* ==================== INTRO LOADING SCREEN ==================== */
        .intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        .intro-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        /* 3D Particle Canvas */
        .particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* High-end Grid Background */
        .intro-grid-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: 
                linear-gradient(rgba(0, 245, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 245, 255, 0.03) 1px, transparent 1px),
                linear-gradient(rgba(191, 0, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(191, 0, 255, 0.02) 1px, transparent 1px);
            background-size: 100px 100px, 100px 100px, 20px 20px, 20px 20px;
            background-position: -1px -1px, -1px -1px, -1px -1px, -1px -1px;
            animation: grid-move 20s linear infinite;
        }

        @keyframes grid-move {
            0% { background-position: -1px -1px, -1px -1px, -1px -1px, -1px -1px; }
            100% { background-position: 99px 99px, 99px 99px, 19px 19px, 19px 19px; }
        }

        /* Grid glow effect */
        .intro-grid-glow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: 
                radial-gradient(ellipse at 30% 20%, rgba(0, 245, 255, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 80%, rgba(191, 0, 255, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(255, 0, 170, 0.05) 0%, transparent 60%);
        }

        /* Intro Content */
        .intro-content {
            position: relative;
            z-index: 10;
            text-align: center;
        }

        /* Glowing Logo */
        .intro-logo {
            font-size: 4rem;
            font-weight: 900;
            letter-spacing: 12px;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple), var(--neon-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: intro-glow 2s ease-in-out infinite alternate, intro-float 3s ease-in-out infinite;
            margin-bottom: 10px;
        }

        @keyframes intro-glow {
            from { 
                filter: drop-shadow(0 0 30px rgba(0, 245, 255, 0.8)) drop-shadow(0 0 60px rgba(191, 0, 255, 0.5));
            }
            to { 
                filter: drop-shadow(0 0 50px rgba(191, 0, 255, 0.8)) drop-shadow(0 0 80px rgba(255, 0, 170, 0.6));
            }
        }

        @keyframes intro-float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .intro-subtitle {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 8px;
            margin-bottom: 60px;
            text-transform: uppercase;
        }

        /* Hexagon Spinner */
        .hex-container {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto 40px;
        }

        .hex-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-radius: 50%;
        }

        .hex-ring:nth-child(1) {
            border-top-color: var(--neon-cyan);
            border-right-color: var(--neon-cyan);
            animation: hex-spin 1.5s linear infinite;
        }

        .hex-ring:nth-child(2) {
            width: 85%;
            height: 85%;
            top: 7.5%;
            left: 7.5%;
            border-bottom-color: var(--neon-purple);
            border-left-color: var(--neon-purple);
            animation: hex-spin 2s linear infinite reverse;
        }

        .hex-ring:nth-child(3) {
            width: 70%;
            height: 70%;
            top: 15%;
            left: 15%;
            border-top-color: var(--neon-pink);
            border-right-color: var(--neon-pink);
            animation: hex-spin 1s linear infinite;
        }

        .hex-core {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, var(--neon-cyan), var(--neon-purple));
            border-radius: 50%;
            animation: core-pulse 1s ease-in-out infinite;
            box-shadow: 0 0 30px var(--neon-cyan), 0 0 60px var(--neon-purple);
        }

        @keyframes hex-spin {
            to { transform: rotate(360deg); }
        }

        @keyframes core-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.7; }
        }

        /* hCaptcha Modal */
        .captcha-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }

        .captcha-modal.active {
            display: flex;
        }

        .captcha-box {
            background: var(--card-bg);
            border: 2px solid var(--neon-cyan);
            border-radius: 15px;
            padding: 30px 40px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 245, 255, 0.3);
        }

        .captcha-title {
            color: var(--neon-cyan);
            font-size: 1.3rem;
            margin-bottom: 10px;
            letter-spacing: 3px;
        }

        .captcha-subtitle {
            color: #888;
            font-size: 0.85rem;
            margin-bottom: 25px;
        }

        .captcha-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .captcha-status {
            margin-top: 15px;
            font-size: 0.9rem;
            color: var(--neon-green);
            display: none;
        }

        .captcha-status.error {
            color: #ff4444;
        }

        .captcha-status.show {
            display: block;
        }

        .captcha-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #666;
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s;
        }

        .captcha-close:hover {
            color: var(--neon-pink);
        }

        /* High-end Progress Bar */
        .intro-progress-container {
            width: 350px;
            margin: 0 auto;
        }

        .intro-progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
        }

        .intro-progress-percent {
            color: var(--neon-cyan);
            font-weight: bold;
        }

        .intro-progress-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .intro-progress-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 255, 255, 0.1) 50%, 
                transparent 100%);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .intro-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-purple), var(--neon-pink));
            border-radius: 3px;
            position: relative;
            transition: width 0.3s ease;
            box-shadow: 0 0 15px var(--neon-cyan), 0 0 30px var(--neon-purple);
        }

        .intro-progress-fill::after {
            content: '';
            position: absolute;
            right: 0;
            top: -4px;
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 0 20px var(--neon-cyan), 0 0 40px var(--neon-cyan);
        }

        /* Loading Status Text */
        .intro-status {
            margin-top: 30px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: var(--neon-green);
            letter-spacing: 1px;
        }

        .intro-status::before {
            content: '> ';
            color: var(--neon-pink);
        }

        .intro-status::after {
            content: '_';
            animation: blink 0.8s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Decorative Elements */
        .intro-decoration {
            position: absolute;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: rgba(0, 245, 255, 0.2);
            pointer-events: none;
        }

        .intro-decoration.top-left {
            top: 30px;
            left: 30px;
        }

        .intro-decoration.top-right {
            top: 30px;
            right: 30px;
            text-align: right;
        }

        .intro-decoration.bottom-left {
            bottom: 30px;
            left: 30px;
        }

        .intro-decoration.bottom-right {
            bottom: 30px;
            right: 30px;
            text-align: right;
        }

        /* Main Content - Hidden during intro */
        .main-content {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.8s ease 0.3s, transform 0.8s ease 0.3s;
        }

        .main-content.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Animated Background */
        .bg-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(191, 0, 255, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(0, 245, 255, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(255, 0, 170, 0.05) 0%, transparent 70%);
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--neon-cyan);
            border-radius: 50%;
            animation: float 15s infinite;
            opacity: 0.5;
        }

        @keyframes float {
            0%, 100% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 0.5; }
            90% { opacity: 0.5; }
            100% { transform: translateY(-100vh) rotate(720deg); opacity: 0; }
        }

        /* Header */
        .header {
            text-align: center;
            padding: 40px 20px;
            position: relative;
        }

        .logo {
            font-size: 3.5rem;
            font-weight: 900;
            letter-spacing: 8px;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple), var(--neon-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 50px rgba(0, 245, 255, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 20px rgba(0, 245, 255, 0.5)); }
            to { filter: drop-shadow(0 0 40px rgba(191, 0, 255, 0.8)); }
        }

        .subtitle {
            font-size: 1rem;
            color: #888;
            margin-top: 10px;
            letter-spacing: 4px;
        }

        .version {
            display: inline-block;
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-pink));
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.75rem;
            margin-top: 15px;
            font-weight: bold;
        }

        /* Main Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px 40px;
        }

        /* Security Status Panel */
        .security-panel {
            background: var(--card-bg);
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .security-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-purple), var(--neon-pink), var(--neon-cyan));
            background-size: 200% 100%;
            animation: gradient-move 3s linear infinite;
        }

        @keyframes gradient-move {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        .security-title {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 1.1rem;
            color: var(--neon-cyan);
        }

        .security-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
        }

        .security-item {
            background: rgba(0, 245, 255, 0.05);
            border: 1px solid rgba(0, 245, 255, 0.1);
            border-radius: 10px;
            padding: 12px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
        }

        .security-item:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--neon-cyan);
            transform: translateY(-2px);
        }

        .security-icon {
            font-size: 1.3rem;
        }

        .security-info {
            flex: 1;
        }

        .security-name {
            font-size: 0.85rem;
            color: #ccc;
        }

        .security-status {
            font-size: 0.7rem;
            color: var(--neon-green);
            font-weight: bold;
        }

        .strength-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }

        .strength-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-cyan));
            border-radius: 2px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Editor Section */
        .editor-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (max-width: 900px) {
            .editor-section {
                grid-template-columns: 1fr;
            }
        }

        .editor-card {
            background: var(--card-bg);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 15px;
            overflow: hidden;
        }

        .editor-header {
            background: rgba(0,0,0,0.3);
            padding: 15px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .editor-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95rem;
        }

        .editor-title-icon {
            font-size: 1.2rem;
        }

        .editor-actions {
            display: flex;
            gap: 10px;
        }

        .btn-small {
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .btn-small:hover {
            background: rgba(255,255,255,0.2);
        }

        textarea {
            width: 100%;
            height: 400px;
            background: var(--darker-bg);
            border: none;
            color: #00ff88;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            padding: 20px;
            resize: none;
            outline: none;
        }

        textarea::placeholder {
            color: #444;
        }

        .output-text {
            color: var(--neon-cyan);
        }

        /* Action Button */
        .action-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .obfuscate-btn {
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-pink));
            border: none;
            color: #fff;
            padding: 18px 60px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            letter-spacing: 3px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 10px 40px rgba(191, 0, 255, 0.4);
        }

        .obfuscate-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 50px rgba(191, 0, 255, 0.6);
        }

        .obfuscate-btn:active {
            transform: translateY(0);
        }

        .obfuscate-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s ease;
        }

        .obfuscate-btn:hover::before {
            left: 100%;
        }

        .obfuscate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Stats Section */
        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-card {
            background: var(--card-bg);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #888;
            margin-top: 5px;
        }

        /* Progress Overlay */
        .progress-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .progress-overlay.active {
            display: flex;
        }

        .progress-content {
            text-align: center;
        }

        .progress-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(255,255,255,0.1);
            border-top-color: var(--neon-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .progress-text {
            font-size: 1.2rem;
            color: var(--neon-cyan);
        }

        .progress-stage {
            font-size: 0.9rem;
            color: #888;
            margin-top: 10px;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--card-bg);
            border: 1px solid var(--neon-green);
            border-radius: 10px;
            padding: 15px 25px;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 1001;
            animation: slideIn 0.3s ease;
        }

        .toast.active {
            display: flex;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .toast-icon {
            font-size: 1.5rem;
        }

        /* Password Section */
        .password-section {
            background: var(--card-bg);
            border: 1px solid rgba(255, 0, 170, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .password-header {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--neon-pink);
            font-size: 1rem;
            margin-bottom: 15px;
        }

        .password-content {
            padding-top: 10px;
        }

        .password-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .password-input-group input {
            flex: 1;
            background: var(--darker-bg);
            border: 1px solid rgba(255, 0, 170, 0.3);
            border-radius: 8px;
            padding: 12px 15px;
            color: var(--neon-pink);
            font-size: 1rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .password-input-group input:focus {
            border-color: var(--neon-pink);
            box-shadow: 0 0 15px rgba(255, 0, 170, 0.3);
        }

        .password-hint {
            font-size: 0.8rem;
            color: #666;
        }

        .mode-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .mode-tab {
            flex: 1;
            padding: 15px;
            background: var(--card-bg);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            color: #888;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-tab:hover {
            border-color: var(--neon-cyan);
            color: #fff;
        }

        .mode-tab.active {
            background: linear-gradient(135deg, rgba(0,245,255,0.2), rgba(191,0,255,0.2));
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            margin-left: auto;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.1);
            border-radius: 26px;
            transition: 0.3s;
        }

        .toggle-slider:before {
            position: absolute;
            content: '';
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background: #fff;
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle-switch input:checked + .toggle-slider {
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-pink));
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        /* SVG Icon Styles */
        .icon-inline {
            width: 18px;
            height: 18px;
            vertical-align: middle;
            margin-right: 5px;
        }

        .icon-title {
            width: 22px;
            height: 22px;
            stroke: var(--neon-cyan);
        }

        .icon-security {
            width: 28px;
            height: 28px;
            flex-shrink: 0;
        }

        .icon-tab {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            vertical-align: middle;
        }

        .icon-editor {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            stroke: var(--neon-cyan);
        }

        .icon-btn {
            width: 14px;
            height: 14px;
            vertical-align: middle;
            margin-right: 4px;
        }

        .icon-btn-large {
            width: 24px;
            height: 24px;
            margin-right: 10px;
            vertical-align: middle;
        }

        .website-link {
            display: block;
            margin-top: 15px;
            color: var(--neon-cyan);
            text-decoration: none;
            font-size: 0.9rem;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }

        .website-link:hover {
            color: var(--neon-pink);
            text-shadow: 0 0 10px var(--neon-pink);
        }

        .mode-tabs {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .mode-tab {
            flex: 1;
            padding: 15px 25px;
            background: var(--card-bg);
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 10px;
            color: #888;
            font-size: 0.9rem;
            font-weight: bold;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mode-tab:hover {
            border-color: var(--neon-cyan);
            color: #fff;
        }

        .mode-tab.active {
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.1), rgba(191, 0, 255, 0.1));
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.2);
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-pink));
            color: #fff;
            padding: 15px 30px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            transition: transform 0.3s ease;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
        }

        .toast.active {
            transform: translateX(-50%) translateY(0);
        }

        .toast-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toast-icon svg {
            width: 22px;
            height: 22px;
        }

        /* Progress Overlay - Hacker Style */
        .progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            overflow: hidden;
        }

        .progress-overlay.active {
            display: flex;
        }

        /* Binary Matrix Background */
        .matrix-bg {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            z-index: 0;
        }

        .matrix-column {
            position: absolute;
            top: -100%;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.2;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan), 0 0 20px var(--neon-cyan);
            animation: matrix-fall linear infinite;
            opacity: 0.8;
            writing-mode: vertical-rl;
            text-orientation: upright;
        }

        @keyframes matrix-fall {
            0% { transform: translateY(0); }
            100% { transform: translateY(250%); }
        }

        /* Scan Lines */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 3px
            );
            pointer-events: none;
            z-index: 2;
        }

        /* Glitch Effect */
        .glitch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(0, 245, 255, 0.03) 50%,
                transparent 100%
            );
            animation: glitch-scan 2s linear infinite;
            z-index: 1;
        }

        @keyframes glitch-scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        .progress-content {
            text-align: center;
            z-index: 10;
            position: relative;
        }

        /* Hacker Terminal Box */
        .terminal-box {
            background: rgba(0, 10, 5, 0.9);
            border: 2px solid var(--neon-cyan);
            border-radius: 10px;
            padding: 40px 60px;
            box-shadow: 
                0 0 30px rgba(0, 245, 255, 0.3),
                inset 0 0 30px rgba(0, 245, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .terminal-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(90deg, #ff5f56, #ffbd2e, #27c93f);
            background-size: 60px 10px;
            background-repeat: no-repeat;
            background-position: 15px center;
        }

        .terminal-header {
            position: absolute;
            top: 5px;
            left: 0;
            right: 0;
            height: 20px;
            display: flex;
            align-items: center;
            padding: 0 15px;
            gap: 8px;
        }

        .terminal-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .terminal-dot.red { background: #ff5f56; }
        .terminal-dot.yellow { background: #ffbd2e; }
        .terminal-dot.green { background: #27c93f; }

        .terminal-title {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 12px;
            font-family: monospace;
        }

        /* Cyber Spinner */
        .cyber-spinner {
            width: 100px;
            height: 100px;
            margin: 30px auto 25px;
            position: relative;
        }

        .cyber-spinner::before,
        .cyber-spinner::after {
            content: '';
            position: absolute;
            border: 3px solid transparent;
            border-radius: 50%;
        }

        .cyber-spinner::before {
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-top-color: var(--neon-cyan);
            border-right-color: var(--neon-cyan);
            animation: spin 1s linear infinite;
        }

        .cyber-spinner::after {
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border-bottom-color: var(--neon-purple);
            border-left-color: var(--neon-purple);
            animation: spin 1.5s linear infinite reverse;
        }

        .spinner-core {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, var(--neon-cyan), transparent);
            border-radius: 50%;
            animation: pulse-core 1s ease-in-out infinite;
        }

        @keyframes pulse-core {
            0%, 100% { opacity: 0.5; transform: translate(-50%, -50%) scale(0.8); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .progress-text {
            font-size: 1.8rem;
            font-family: 'Courier New', monospace;
            color: var(--neon-cyan);
            letter-spacing: 6px;
            text-shadow: 0 0 10px var(--neon-cyan), 0 0 20px var(--neon-cyan);
            animation: text-flicker 0.1s infinite;
        }

        @keyframes text-flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .progress-stage {
            margin-top: 15px;
            color: var(--neon-green);
            font-size: 0.95rem;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
        }

        .progress-stage::before {
            content: '> ';
            color: var(--neon-pink);
        }

        /* Progress Bar */
        .cyber-progress {
            margin-top: 20px;
            height: 4px;
            background: rgba(0, 245, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }

        .cyber-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-purple), var(--neon-pink));
            background-size: 200% 100%;
            animation: progress-glow 1s linear infinite;
            transition: width 0.3s ease;
        }

        @keyframes progress-glow {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        /* Binary Text Animation */
        .binary-text {
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: rgba(0, 245, 255, 0.4);
            letter-spacing: 2px;
            overflow: hidden;
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .logo { font-size: 2rem; }
            .editor-section { grid-template-columns: 1fr; }
            .security-grid { grid-template-columns: 1fr 1fr; }
        }
    </style>
</head>
<body>
    <!-- ==================== INTRO LOADING SCREEN ==================== -->
    <div class="intro-screen" id="introScreen">
        <!-- Grid Background -->
        <div class="intro-grid-bg"></div>
        <div class="intro-grid-glow"></div>
        <!-- Snowflake Canvas -->
        <canvas class="particle-canvas" id="particleCanvas"></canvas>
        
        <!-- Decorative corners -->
        <div class="intro-decoration top-left">
            SYS.INIT<br>
            MEM: 0x7FFF<br>
            CPU: ACTIVE
        </div>
        <div class="intro-decoration top-right">
            v3.2.0<br>
            BUILD: 2026<br>
            SECURE: ON
        </div>
        <div class="intro-decoration bottom-left">
            PROTOCOL: AES-256<br>
            LAYER: QUANTUM<br>
            STATUS: READY
        </div>
        <div class="intro-decoration bottom-right">
            luau.gkop.cc<br>
            PORT: 443<br>
            TLS: 1.3
        </div>
        
        <div class="intro-content">
            <h1 class="intro-logo">SHADOW CIPHER</h1>
            <p class="intro-subtitle">Ultimate Encryption System</p>
            
            <div class="hex-container">
                <div class="hex-ring"></div>
                <div class="hex-ring"></div>
                <div class="hex-ring"></div>
                <div class="hex-core"></div>
            </div>
            
            <div class="intro-progress-container">
                <div class="intro-progress-label">
                    <span>INITIALIZING SYSTEM</span>
                    <span class="intro-progress-percent" id="introPercent">0%</span>
                </div>
                <div class="intro-progress-bar">
                    <div class="intro-progress-fill" id="introProgressFill" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="intro-status" id="introStatus">Loading core modules...</div>
        </div>
    </div>

    <!-- ==================== MAIN CONTENT ==================== -->
    <div class="main-content" id="mainContent">
        <div class="bg-animation"></div>
        <div class="particles" id="particles"></div>

        <header class="header">
        <h1 class="logo">SHADOW CIPHER</h1>
        <p class="subtitle">ULTIMATE ROBLOX LUAU OBFUSCATOR</p>
        <span class="version">
            <svg class="icon-inline" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
            MAXIMUM SECURITY v3.2.0
        </span>
        <a href="https://luau.gkop.cc" target="_blank" class="website-link">luau.gkop.cc</a>
    </header>

    <main class="container">
        <!-- Security Panel -->
        <div class="security-panel">
            <div class="security-title">
                <svg class="icon-title" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
                <span>ACTIVE SECURITY LAYERS</span>
            </div>
            <div class="security-grid">
                <div class="security-item">
                    <svg class="icon-security" viewBox="0 0 24 24" fill="none" stroke="var(--neon-cyan)" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/><circle cx="12" cy="16" r="1"/></svg>
                    <div class="security-info">
                        <div class="security-name">Variable Mutation</div>
                        <div class="security-status">MAXIMUM</div>
                        <div class="strength-bar"><div class="strength-fill" style="width:100%"></div></div>
                    </div>
                </div>
                <div class="security-item">
                    <svg class="icon-security" viewBox="0 0 24 24" fill="none" stroke="var(--neon-purple)" stroke-width="2"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/></svg>
                    <div class="security-info">
                        <div class="security-name">String Encryption</div>
                        <div class="security-status">MAXIMUM</div>
                        <div class="strength-bar"><div class="strength-fill" style="width:100%"></div></div>
                    </div>
                </div>
                <div class="security-item">
                    <svg class="icon-security" viewBox="0 0 24 24" fill="none" stroke="var(--neon-pink)" stroke-width="2"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2z"/><path d="M12 6v6l4 2"/></svg>
                    <div class="security-info">
                        <div class="security-name">Control Flow</div>
                        <div class="security-status">MAXIMUM</div>
                        <div class="strength-bar"><div class="strength-fill" style="width:100%"></div></div>
                    </div>
                </div>
                <div class="security-item">
                    <svg class="icon-security" viewBox="0 0 24 24" fill="none" stroke="var(--neon-green)" stroke-width="2"><polyline points="3 6 5 6 6 6"/><path d="M6 6h12l1 14H5L6 6z"/><path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"/></svg>
                    <div class="security-info">
                        <div class="security-name">Junk Injection</div>
                        <div class="security-status">MAXIMUM</div>
                        <div class="strength-bar"><div class="strength-fill" style="width:100%"></div></div>
                    </div>
                </div>
                <div class="security-item">
                    <svg class="icon-security" viewBox="0 0 24 24" fill="none" stroke="var(--neon-cyan)" stroke-width="2"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/></svg>
                    <div class="security-info">
                        <div class="security-name">Code Compression</div>
                        <div class="security-status">MAXIMUM</div>
                        <div class="strength-bar"><div class="strength-fill" style="width:100%"></div></div>
                    </div>
                </div>
                <div class="security-item">
                    <svg class="icon-security" viewBox="0 0 24 24" fill="none" stroke="var(--neon-purple)" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/><path d="M9 12l2 2 4-4"/></svg>
                    <div class="security-info">
                        <div class="security-name">Anti-Tamper</div>
                        <div class="security-status">MAXIMUM</div>
                        <div class="strength-bar"><div class="strength-fill" style="width:100%"></div></div>
                    </div>
                </div>
                <div class="security-item">
                    <svg class="icon-security" viewBox="0 0 24 24" fill="none" stroke="var(--neon-pink)" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>
                    <div class="security-info">
                        <div class="security-name">Password Lock</div>
                        <div class="security-status" id="pwdStatus">OPTIONAL</div>
                        <div class="strength-bar"><div class="strength-fill" id="pwdStrength" style="width:0%"></div></div>
                    </div>
                </div>
                <div class="security-item">
                    <svg class="icon-security" viewBox="0 0 24 24" fill="none" stroke="#ff6600" stroke-width="2"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>
                    <div class="security-info">
                        <div class="security-name">VM Protection</div>
                        <div class="security-status" style="color:#ff6600;">ALWAYS ON</div>
                        <div class="strength-bar"><div class="strength-fill" style="width:100%;background:linear-gradient(90deg,#ff6600,#ff0044);"></div></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Password Section -->
        <div class="password-section">
            <div class="password-header">
                <svg class="icon-title" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/><circle cx="12" cy="16" r="1"/></svg>
                <span>PASSWORD PROTECTION</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="enablePassword" onchange="togglePassword()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="password-content" id="passwordContent" style="display:none;">
                <div class="password-input-group">
                    <input type="password" id="scriptPassword" placeholder="Enter protection password..." oninput="updatePasswordStrength()">
                    <button class="btn-small" onclick="togglePasswordVisibility()">
                        <svg class="icon-btn" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                    </button>
                </div>
                <div class="password-hint">This password will be required to run the obfuscated script</div>
            </div>
        </div>


        <!-- Mode Tabs -->
        <div class="mode-tabs">
            <button class="mode-tab active" id="tabEncrypt" onclick="switchMode('encrypt')">
                <svg class="icon-tab" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
                ENCRYPT
            </button>
            <button class="mode-tab" id="tabDecrypt" onclick="switchMode('decrypt')">
                <svg class="icon-tab" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>
                DECRYPT
            </button>
        </div>

        <!-- Encrypt Mode -->
        <div id="encryptMode">
            <div class="editor-section">
                <div class="editor-card">
                    <div class="editor-header">
                        <div class="editor-title">
                            <svg class="icon-editor" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                            <span>INPUT CODE</span>
                        </div>
                        <div class="editor-actions">
                            <button class="btn-small" onclick="loadSample()"><svg class="icon-btn" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Sample</button>
                            <button class="btn-small" onclick="clearInput()"><svg class="icon-btn" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg> Clear</button>
                        </div>
                    </div>
                    <textarea id="inputCode" placeholder="-- Paste your Lua/Luau code here...

local player = game.Players.LocalPlayer
print('Hello World!')"></textarea>
                </div>
                <div class="editor-card">
                    <div class="editor-header">
                        <div class="editor-title">
                            <svg class="icon-editor" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
                            <span>OBFUSCATED OUTPUT</span>
                        </div>
                        <div class="editor-actions">
                            <button class="btn-small" onclick="copyOutput()"><svg class="icon-btn" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy</button>
                            <button class="btn-small" onclick="downloadOutput()"><svg class="icon-btn" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg> Download</button>
                        </div>
                    </div>
                    <textarea id="outputCode" class="output-text" readonly placeholder="Obfuscated code will appear here..."></textarea>
                </div>
            </div>
        </div>

        <!-- Decrypt Mode -->
        <div id="decryptMode" style="display:none;">
            <div class="editor-section">
                <div class="editor-card">
                    <div class="editor-header">
                        <div class="editor-title">
                            <svg class="icon-editor" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
                            <span>ENCRYPTED CODE</span>
                        </div>
                        <div class="editor-actions">
                            <button class="btn-small" onclick="clearDecryptInput()"><svg class="icon-btn" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg> Clear</button>
                        </div>
                    </div>
                    <textarea id="decryptInput" placeholder="-- Paste obfuscated code here..."></textarea>
                </div>
                <div class="editor-card">
                    <div class="editor-header">
                        <div class="editor-title">
                            <svg class="icon-editor" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                            <span>DECRYPTED OUTPUT</span>
                        </div>
                        <div class="editor-actions">
                            <button class="btn-small" onclick="copyDecrypted()"><svg class="icon-btn" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy</button>
                        </div>
                    </div>
                    <textarea id="decryptOutput" class="output-text" style="color:#00ff88;" readonly placeholder="Decrypted code will appear here..."></textarea>
                </div>
            </div>
            <div class="action-section">
                <button class="obfuscate-btn" style="background:linear-gradient(135deg,#00f5ff,#00ff88);" onclick="decryptCode()">
                    <svg class="icon-btn-large" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>
                    DECRYPT
                </button>
            </div>
        </div>

        <!-- Action Button -->
        <div class="action-section">
            <button class="obfuscate-btn" id="obfuscateBtn" onclick="obfuscate()">
                <svg class="icon-btn-large" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>
                OBFUSCATE
            </button>
        </div>

        <!-- Stats Section -->
        <div class="stats-section">
            <div class="stat-card">
                <div class="stat-value" id="statOriginal">0</div>
                <div class="stat-label">Original Size (bytes)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statObfuscated">0</div>
                <div class="stat-label">Obfuscated Size (bytes)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statChange">0%</div>
                <div class="stat-label">Size Change</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statVars">0</div>
                <div class="stat-label">Variables Renamed</div>
            </div>
        </div>
    </main>
    </div><!-- END main-content -->

    <!-- Progress Overlay - Hacker Style -->
    <div class="progress-overlay" id="progressOverlay">
        <!-- Binary Matrix Background -->
        <div class="matrix-bg" id="matrixBg"></div>
        <!-- Scan Lines -->
        <div class="scanlines"></div>
        <!-- Glitch Effect -->
        <div class="glitch-overlay"></div>
        
        <div class="progress-content">
            <div class="terminal-box">
                <div class="terminal-header">
                    <div class="terminal-dot red"></div>
                    <div class="terminal-dot yellow"></div>
                    <div class="terminal-dot green"></div>
                </div>
                <span class="terminal-title">shadow_cipher.exe</span>
                
                <div class="cyber-spinner">
                    <div class="spinner-core"></div>
                </div>
                
                <div class="progress-text" id="progressText">ENCRYPTING</div>
                <div class="progress-stage" id="progressStage">Initializing system...</div>
                
                <div class="cyber-progress">
                    <div class="cyber-progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
                
                <div class="binary-text" id="binaryText">01001000 01000001 01000011 01001011</div>
            </div>
        </div>
    </div>

    <!-- hCaptcha Modal -->
    <div class="captcha-modal" id="captchaModal">
        <div class="captcha-box">
            <div class="captcha-title">HUMAN VERIFICATION</div>
            <div class="captcha-subtitle">Please complete the captcha to continue</div>
            <div class="captcha-container">
                <div class="h-captcha" 
                     data-sitekey="b5fe66c4-5c6c-47ca-8542-d0b8f82e2228"
                     data-callback="onCaptchaSuccess"
                     data-expired-callback="onCaptchaExpired"
                     data-error-callback="onCaptchaError"
                     data-theme="dark">
                </div>
            </div>
            <div class="captcha-status" id="captchaStatus"></div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast">
        <span class="toast-icon" id="toastIcon"></span>
        <span id="toastText">Success!</span>
    </div>

    <script>
        // ==================== SNOWFLAKE INTRO ANIMATION ====================
        class Snowflake {
            constructor(canvas) {
                this.canvas = canvas;
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * this.canvas.width;
                this.y = -20;
                this.size = Math.random() * 4 + 2;
                this.speedY = Math.random() * 2 + 1;
                this.speedX = Math.random() * 1 - 0.5;
                this.opacity = Math.random() * 0.6 + 0.4;
                this.swing = Math.random() * 2;
                this.swingSpeed = Math.random() * 0.02 + 0.01;
                this.angle = Math.random() * Math.PI * 2;
                // Neon colors for cyber effect
                const colors = ['#00f5ff', '#bf00ff', '#ff00aa', '#00ff88', '#ffffff'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
            }
            
            update() {
                this.y += this.speedY;
                this.angle += this.swingSpeed;
                this.x += Math.sin(this.angle) * this.swing + this.speedX;
                
                if (this.y > this.canvas.height + 20) {
                    this.reset();
                }
                if (this.x > this.canvas.width + 20) this.x = -20;
                if (this.x < -20) this.x = this.canvas.width + 20;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                
                // Draw snowflake shape (6-pointed star)
                ctx.beginPath();
                const spikes = 6;
                const outerRadius = this.size;
                const innerRadius = this.size * 0.4;
                
                for (let i = 0; i < spikes * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i * Math.PI) / spikes - Math.PI / 2;
                    const x = this.x + Math.cos(angle) * radius;
                    const y = this.y + Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                // Center dot
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Initialize snowflakes for intro
        let snowflakes = [];
        let introAnimationId = null;
        
        function initSnowflakes() {
            const canvas = document.getElementById('particleCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            snowflakes = [];
            // Create initial snowflakes spread across the screen
            for (let i = 0; i < 150; i++) {
                const sf = new Snowflake(canvas);
                sf.y = Math.random() * canvas.height; // Spread initial position
                snowflakes.push(sf);
            }
            
            function animate() {
                // Semi-transparent clear for trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                snowflakes.forEach(sf => {
                    sf.update();
                    sf.draw(ctx);
                });
                
                introAnimationId = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        // Intro loading sequence
        async function runIntroSequence() {
            // Check if already loaded this session
            if (sessionStorage.getItem('introShown')) {
                // Skip intro, show main content immediately
                const introScreen = document.getElementById('introScreen');
                const mainContent = document.getElementById('mainContent');
                if (introScreen) introScreen.style.display = 'none';
                if (mainContent) mainContent.classList.add('visible');
                return;
            }
            
            // Mark intro as shown for this session
            sessionStorage.setItem('introShown', 'true');
            
            initSnowflakes();
            
            const stages = [
                { text: 'Loading core modules...', percent: 10 },
                { text: 'Initializing encryption engine...', percent: 25 },
                { text: 'Configuring security protocols...', percent: 40 },
                { text: 'Loading obfuscation algorithms...', percent: 55 },
                { text: 'Preparing user interface...', percent: 70 },
                { text: 'Verifying system integrity...', percent: 85 },
                { text: 'System ready!', percent: 100 }
            ];
            
            const progressFill = document.getElementById('introProgressFill');
            const progressPercent = document.getElementById('introPercent');
            const statusText = document.getElementById('introStatus');
            
            for (const stage of stages) {
                if (progressFill) progressFill.style.width = stage.percent + '%';
                if (progressPercent) progressPercent.textContent = stage.percent + '%';
                if (statusText) statusText.textContent = stage.text;
                await new Promise(r => setTimeout(r, 400));
            }
            
            // Wait a moment then hide intro
            await new Promise(r => setTimeout(r, 500));
            
            // Hide intro and show main content
            const introScreen = document.getElementById('introScreen');
            const mainContent = document.getElementById('mainContent');
            
            if (introScreen) introScreen.classList.add('hidden');
            if (mainContent) mainContent.classList.add('visible');
            
            // Stop snowflake animation after fade out
            setTimeout(() => {
                if (introAnimationId) {
                    cancelAnimationFrame(introAnimationId);
                    introAnimationId = null;
                }
            }, 1000);
        }
        
        // Handle window resize for canvas
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('particleCanvas');
            if (canvas && document.getElementById('introScreen') && 
                !document.getElementById('introScreen').classList.contains('hidden')) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        });
        
        // Start intro on page load
        window.addEventListener('load', runIntroSequence);

        // ==================== hCAPTCHA VERIFICATION ====================
        let captchaVerified = false;
        let pendingObfuscation = false;
        
        function showCaptchaModal() {
            const modal = document.getElementById('captchaModal');
            modal.classList.add('active');
            // Reset captcha if needed
            if (typeof hcaptcha !== 'undefined') {
                hcaptcha.reset();
            }
        }
        
        function hideCaptchaModal() {
            const modal = document.getElementById('captchaModal');
            modal.classList.remove('active');
        }
        
        function onCaptchaSuccess(token) {
            captchaVerified = true;
            const status = document.getElementById('captchaStatus');
            status.textContent = 'Verification successful!';
            status.className = 'captcha-status show';
            
            // Auto-hide modal and proceed with obfuscation
            setTimeout(() => {
                hideCaptchaModal();
                if (pendingObfuscation) {
                    pendingObfuscation = false;
                    performObfuscation();
                }
            }, 800);
        }
        
        function onCaptchaExpired() {
            captchaVerified = false;
            const status = document.getElementById('captchaStatus');
            status.textContent = 'Captcha expired. Please try again.';
            status.className = 'captcha-status show error';
        }
        
        function onCaptchaError() {
            captchaVerified = false;
            const status = document.getElementById('captchaStatus');
            status.textContent = 'Verification error. Please try again.';
            status.className = 'captcha-status show error';
        }
        
        // ==================== MAIN APP CODE ====================
        
        // Particle Effect for main page
        const particlesContainer = document.getElementById('particles');
        if (particlesContainer) {
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 15 + 's';
                particle.style.animationDuration = (10 + Math.random() * 10) + 's';
                particlesContainer.appendChild(particle);
            }
        }

        // Matrix Binary Rain Effect
        let matrixInterval = null;
        function initMatrix() {
            const matrixBg = document.getElementById('matrixBg');
            matrixBg.innerHTML = '';
            const columns = Math.floor(window.innerWidth / 20);
            
            for (let i = 0; i < columns; i++) {
                const column = document.createElement('div');
                column.className = 'matrix-column';
                column.style.left = (i * 20) + 'px';
                column.style.animationDuration = (3 + Math.random() * 4) + 's';
                column.style.animationDelay = (Math.random() * 3) + 's';
                
                // Generate binary string
                let binary = '';
                const length = 20 + Math.floor(Math.random() * 30);
                for (let j = 0; j < length; j++) {
                    binary += Math.random() > 0.5 ? '1' : '0';
                }
                column.textContent = binary;
                
                // Random color variation
                const colors = ['#00f5ff', '#00ff88', '#bf00ff', '#ff00aa'];
                column.style.color = colors[Math.floor(Math.random() * colors.length)];
                column.style.opacity = 0.3 + Math.random() * 0.5;
                
                matrixBg.appendChild(column);
            }
        }

        // Animate binary text
        function animateBinaryText() {
            const binaryText = document.getElementById('binaryText');
            if (!binaryText) return;
            
            let text = '';
            for (let i = 0; i < 32; i++) {
                text += Math.random() > 0.5 ? '1' : '0';
                if ((i + 1) % 8 === 0 && i < 31) text += ' ';
            }
            binaryText.textContent = text;
        }

        // Update progress bar and binary text during obfuscation
        function updateProgress(percent, stage) {
            const progressFill = document.getElementById('progressFill');
            const progressStage = document.getElementById('progressStage');
            const progressText = document.getElementById('progressText');
            
            if (progressFill) progressFill.style.width = percent + '%';
            if (progressStage) progressStage.textContent = stage;
            
            // Update text based on progress
            if (progressText) {
                if (percent < 30) progressText.textContent = 'ANALYZING';
                else if (percent < 60) progressText.textContent = 'ENCRYPTING';
                else if (percent < 90) progressText.textContent = 'OBFUSCATING';
                else progressText.textContent = 'FINALIZING';
            }
            
            animateBinaryText();
        }

        // Show/hide progress overlay with matrix effect
        function showProgressOverlay() {
            const overlay = document.getElementById('progressOverlay');
            overlay.classList.add('active');
            initMatrix();
            matrixInterval = setInterval(animateBinaryText, 100);
        }

        function hideProgressOverlay() {
            const overlay = document.getElementById('progressOverlay');
            overlay.classList.remove('active');
            if (matrixInterval) {
                clearInterval(matrixInterval);
                matrixInterval = null;
            }
        }

        // Luau Keywords and Globals
        const LUAU_KEYWORDS = new Set([
            'and', 'break', 'do', 'else', 'elseif', 'end', 'false', 'for', 'function',
            'if', 'in', 'local', 'nil', 'not', 'or', 'repeat', 'return', 'then',
            'true', 'until', 'while', 'continue', 'type', 'export', 'typeof'
        ]);

        const ROBLOX_GLOBALS = new Set([
            'game', 'workspace', 'script', 'Instance', 'Vector3', 'Vector2', 'CFrame',
            'Color3', 'BrickColor', 'Enum', 'UDim', 'UDim2', 'Ray', 'Region3', 'Rect',
            'TweenInfo', 'NumberSequence', 'ColorSequence', 'NumberRange', 'Faces',
            'Axes', 'RaycastParams', 'OverlapParams', 'Random', 'DateTime', 'task',
            'coroutine', 'debug', 'math', 'string', 'table', 'os', 'utf8', 'bit32',
            'buffer', 'pcall', 'xpcall', 'spawn', 'delay', 'wait', 'warn', 'print',
            'error', 'assert', 'select', 'next', 'pairs', 'ipairs', 'type', 'typeof',
            'tonumber', 'tostring', 'rawget', 'rawset', 'rawequal', 'rawlen',
            'setmetatable', 'getmetatable', 'require', 'newproxy', 'gcinfo',
            'collectgarbage', 'tick', 'time', 'elapsedTime', '_G', 'shared', '_VERSION'
        ]);

        let varMap = {};
        let varCounter = 0;

        // Multiple naming strategies to defeat regex pattern matching
        function generateVarName() {
            const strategy = Math.floor(Math.random() * 4);
            varCounter++;
            switch(strategy) {
                case 0: { // lI10 confusion
                    const c = ['_','l','I','1','O','0','i','L'];
                    let n = '_'; for(let i=0;i<4+Math.floor(Math.random()*4);i++) n+=c[Math.floor(Math.random()*c.length)];
                    return n+varCounter;
                }
                case 1: { // Unicode-like with valid Lua identifiers
                    const p = ['_a','_b','_c','_d','_e','_f'];
                    let n = p[Math.floor(Math.random()*p.length)];
                    for(let i=0;i<3+Math.floor(Math.random()*4);i++) n+=String.fromCharCode(97+Math.floor(Math.random()*26));
                    return n+varCounter;
                }
                case 2: { // Double underscore prefix
                    let n = '__'; for(let i=0;i<4+Math.floor(Math.random()*4);i++) n+=String.fromCharCode(Math.random()>0.5?65+Math.floor(Math.random()*26):97+Math.floor(Math.random()*26));
                    return n+varCounter;
                }
                default: { // Looks like real variable names
                    const words = ['data','val','tmp','buf','res','idx','len','key','src','ctx','ref','ptr','obj','fn','cb','st','flag','cnt','pos','arg'];
                    return '_'+words[Math.floor(Math.random()*words.length)]+words[Math.floor(Math.random()*words.length)]+'_'+varCounter;
                }
            }
        }

        function hasNonAscii(str) {
            for (let i = 0; i < str.length; i++) {
                if (str.charCodeAt(i) > 127) return true;
            }
            return false;
        }

        // Convert string to byte array format for Chinese/Unicode protection
        function stringToByteArray(str) {
            const bytes = [];
            for (let i = 0; i < str.length; i++) {
                const code = str.charCodeAt(i);
                if (code > 255) {
                    // UTF-16 to UTF-8 conversion for Chinese chars
                    if (code > 0x7FF) {
                        bytes.push(0xE0 | (code >> 12));
                        bytes.push(0x80 | ((code >> 6) & 0x3F));
                        bytes.push(0x80 | (code & 0x3F));
                    } else {
                        bytes.push(0xC0 | (code >> 6));
                        bytes.push(0x80 | (code & 0x3F));
                    }
                } else {
                    bytes.push(code);
                }
            }
            return bytes;
        }

        // ==================== MULTI-ALGORITHM STRING ENCRYPTION ====================
        // 5 completely different encryption algorithms chosen randomly
        // Makes pattern-matching deobfuscation impossible
        
        function encryptString(str) {
            if (str.length === 0) return '""';
            
            // For non-ASCII, always use byte array with random algorithm
            if (hasNonAscii(str)) {
                return encryptNonAscii(str);
            }
            
            // Only split long strings; short ones use single algorithm
            if (str.length > 12) {
                const parts = [];
                const partLen = Math.ceil(str.length / 2);
                for (let i = 0; i < str.length; i += partLen) {
                    parts.push(str.substring(i, i + partLen));
                }
                return '(' + parts.map(p => encryptSingleString(p)).join('..') + ')';
            }
            return encryptSingleString(str);
        }
        
        function encryptNonAscii(str) {
            const bytes = stringToByteArray(str);
            const algo = Math.floor(Math.random() * 3);
            
            if (algo === 0) {
                // Dual-key XOR with position scramble
                const k1 = Math.floor(Math.random()*50)+10;
                const k2 = Math.floor(Math.random()*50)+10;
                const enc = bytes.map((b,i) => (b ^ k1 ^ ((i*k2)%256)));
                const vK1=generateVarName(),vK2=generateVarName(),vArr=generateVarName(),vRes=generateVarName();
                const vI=generateVarName(),vB=generateVarName();
                const fk=Math.floor(Math.random()*9999);
                return `(function()local ${vK1}=bit32.bxor(${k1^fk},${fk})local ${vK2}=${k2} local ${vArr}={${enc.join(',')}}local ${vRes}=""for ${vI}=1,#${vArr} do local ${vB}=bit32.bxor(${vArr}[${vI}],bit32.bxor(${vK1},(${vI}-1)*${vK2}%256))${vRes}=${vRes}..string.char(${vB})end return ${vRes} end)()`;
            } else if (algo === 1) {
                // Forward build with obfuscated key
                const k = Math.floor(Math.random()*40)+10;
                const enc = bytes.map(b => b ^ k);
                const vArr=generateVarName(),vRes=generateVarName(),vI=generateVarName(),vK=generateVarName();
                const fk=Math.floor(Math.random()*9999);
                return `(function()local ${vK}=bit32.bxor(${k^fk},${fk})local ${vArr}={${enc.join(',')}}local ${vRes}={}for ${vI}=1,#${vArr} do ${vRes}[${vI}]=string.char(bit32.bxor(${vArr}[${vI}],${vK}))end return table.concat(${vRes})end)()`;
            } else {
                // Table lookup cipher
                const k = Math.floor(Math.random()*50)+10;
                const enc = bytes.map(b => b ^ k);
                const vT=generateVarName(),vR=generateVarName(),vK=generateVarName(),vI=generateVarName(),vV=generateVarName();
                const fk=Math.floor(Math.random()*9999);
                return `(function()local ${vT}={${enc.join(',')}}local ${vR}={}local ${vK}=bit32.bxor(${k^fk},${fk})for ${vI},${vV} in ipairs(${vT})do ${vR}[#${vR}+1]=string.char(bit32.bxor(${vV},${vK}))end return table.concat(${vR})end)()`;
            }
        }
        
        function encryptSingleString(str) {
            if (str.length === 0) return '""';
            
            // Randomly pick from 4 compact encryption algorithms
            const algo = Math.floor(Math.random() * 4);
            
            switch(algo) {
                case 0: return encryptAlgo_DualXorChain(str);
                case 1: return encryptAlgo_ByteShuffleReverse(str);
                case 2: return encryptAlgo_TableLookupCipher(str);
                default: return encryptAlgo_MathHeavy(str);
            }
        }
        
        // Algorithm 1: Dual XOR chain with position-dependent keys (original but evolved)
        function encryptAlgo_DualXorChain(str) {
            const k1 = Math.floor(Math.random()*100)+50;
            const k2 = Math.floor(Math.random()*50)+20;
            const k3 = Math.floor(Math.random()*30)+60;
            const step = Math.floor(Math.random()*3)+2;
            const enc = [];
            for(let i=0;i<str.length;i++) {
                const c = str.charCodeAt(i);
                enc.push(((c ^ ((k1+(i*step))%128)) ^ k2) + k3 + i);
            }
            const v=()=>generateVarName();
            const vk=v(),vs=v(),vo=v(),vm=v(),va=v(),vr=v(),vi=v(),vj=v(),vv=v();
            const fk=Math.floor(Math.random()*9999);
            // Opaque predicate wrapping
            const opaque = generateOpaquePredicate();
            return `(function()${opaque}local ${vk}=bit32.bxor(${k1^fk},${fk})local ${vs}=${k2} local ${vo}=${k3} local ${vm}=${step} local ${va}={${enc.join(',')}}local ${vr}={}local ${vi}=0 for ${vj},${vv} in ipairs(${va})do ${vr}[${vi}+1]=string.char(bit32.bxor(bit32.bxor(${vv}-${vo}-${vi},bit32.band(${vk}+(${vi}*${vm}),127)),${vs}))${vi}=${vi}+1 end return table.concat(${vr})end)()`;
        }
        
        // Algorithm 2: Byte shuffle + reverse build
        function encryptAlgo_ByteShuffleReverse(str) {
            const k = Math.floor(Math.random()*90)+30;
            const enc = [];
            // Encrypt in reverse order
            for(let i=str.length-1;i>=0;i--) {
                enc.push(str.charCodeAt(i) ^ ((k + i*7) % 256));
            }
            const va=generateVarName(),vr=generateVarName(),vi=generateVarName(),vv=generateVarName(),vk=generateVarName();
            const fk=Math.floor(Math.random()*9999);
            const opaque = generateOpaquePredicate();
            return `(function()${opaque}local ${va}={${enc.join(',')}}local ${vr}={}local ${vk}=bit32.bxor(${k^fk},${fk})for ${vi}=#${va},1,-1 do local ${vv}=bit32.bxor(${va}[${vi}],(${vk}+(#${va}-${vi})*7)%256)${vr}[#${va}-${vi}+1]=string.char(${vv})end return table.concat(${vr})end)()`;
        }
        
        // Algorithm 3: Dual table lookup cipher
        function encryptAlgo_TableLookupCipher(str) {
            // Create a substitution table
            const seed = Math.floor(Math.random()*200)+50;
            const enc = [];
            for(let i=0;i<str.length;i++) {
                const c = str.charCodeAt(i);
                // Multi-layer: XOR with seed, add position hash, XOR with rotated seed
                const v = ((c ^ (seed % 128)) + (i * 3 + 7)) ^ ((seed >> 2) % 64);
                enc.push(v);
            }
            const va=generateVarName(),vr=generateVarName(),vi=generateVarName(),vv=generateVarName(),vk=generateVarName();
            const fk1=Math.floor(Math.random()*9999),fk2=Math.floor(Math.random()*9999);
            const opaque = generateOpaquePredicate();
            return `(function()${opaque}local ${vk}=bit32.bxor(${seed^fk1},${fk1})local ${va}={${enc.join(',')}}local ${vr}={}for ${vi}=1,#${va} do local ${vv}=bit32.bxor(${va}[${vi}],(bit32.rshift(${vk},2))%64)${vv}=${vv}-(${vi}-1)*3-7 ${vr}[${vi}]=string.char(bit32.bxor(${vv},${vk}%128))end return table.concat(${vr})end)()`;
        }
        
        // Algorithm 4: Nested IIFE with scattered computation
        function encryptAlgo_NestedIIFE(str) {
            // Each character decrypted by its own mini-function
            const k = Math.floor(Math.random()*100)+20;
            const parts = [];
            for(let i=0;i<str.length;i++) {
                const c = str.charCodeAt(i);
                const encrypted = c ^ ((k + i * 5) % 128);
                const fk = Math.floor(Math.random()*9999);
                parts.push(`string.char(bit32.bxor(${encrypted},bit32.band(bit32.bxor(${k^fk},${fk})+${i}*5,127)))`);
            }
            const opaque = generateOpaquePredicate();
            return `(function()${opaque}return ${parts.join('..')}end)()`;
        }
        
        // Algorithm 5: Heavy math with dual-layer XOR
        function encryptAlgo_MathHeavy(str) {
            const k1 = Math.floor(Math.random()*50)+30;
            const k2 = Math.floor(Math.random()*50)+10;
            const enc = [];
            for(let i=0;i<str.length;i++) {
                const c = str.charCodeAt(i);
                enc.push((c ^ k1) ^ ((k2 + i) % 256));
            }
            const va=generateVarName(),vr=generateVarName(),vi=generateVarName(),vk1=generateVarName(),vk2=generateVarName();
            const fk=Math.floor(Math.random()*9999);
            const opaque = generateOpaquePredicate();
            return `(function()${opaque}local ${va}={${enc.join(',')}}local ${vr}={}local ${vk1}=bit32.bxor(${k1^fk},${fk})local ${vk2}=${k2} for ${vi}=1,#${va} do ${vr}[${vi}]=string.char(bit32.bxor(bit32.bxor(${va}[${vi}],${vk1}),(${vk2}+${vi}-1)%256))end return table.concat(${vr})end)()`;
        }
        
        // ==================== OPAQUE PREDICATES ====================
        // Conditions that ALWAYS evaluate to true but look complex
        function generateOpaquePredicate() {
            // IMPORTANT: predicates must NOT call tostring/print/warn/error/tonumber
            // because function call obfuscation would replace them and cause nil refs
            const predicates = [
                () => { const v=generateVarName(); return `if math.pi>3 then local ${v}=0 else return""end `; },
                () => { const v=generateVarName(); return `if bit32.bxor(${Math.floor(Math.random()*999)},${Math.floor(Math.random()*999)})>-1 then local ${v}=0 else return nil end `; },
                () => { return ``; },
                () => { return ``; },
                () => { return ``; },
                () => { return ``; },
                () => { return ``; },
            ];
            return predicates[Math.floor(Math.random()*predicates.length)]();
        }

        // ==================== ANTI-ANALYSIS JUNK CODE ====================
        // Junk that references real globals and creates interconnected fake logic
        // Dead-code elimination cannot safely remove these
        function generateJunk() {
            const n = () => Math.floor(Math.random()*9999);
            const v = () => generateVarName();
            const patterns = [
                // Interconnected: variable used in a later condition
                () => { const a=v(),b=v(); return `local ${a}=bit32.bxor(${n()},${n()})local ${b}=${a}%256`; },
                // Type check that looks real
                () => `local ${v()}=type(game)=="userdata"and type(workspace)or""`,
                // pcall wrapped fake computation
                () => { const a=v(); return `local _,${a}=pcall(function()return bit32.band(${n()},${n()})end)`; },
                // Fake coroutine
                () => `local ${v()}=coroutine.create(function()local ${v()}=${n()} end)`,
                // String computation that looks real
                () => `local ${v()}=string.rep(string.char(${32+Math.floor(Math.random()*90)}),${Math.floor(Math.random()*3)+1})`,
                // Opaque predicate + nested junk
                () => { const a=v(),b=v(); return `local ${a}=${n()} if math.pi>3 then ${a}=bit32.bxor(${a},${n()})end local ${b}=${a}`; },
                // Table manipulation
                () => { const a=v(),b=v(); return `local ${a}={${n()},${n()},${n()}}${a}[#${a}+1]=bit32.bxor(${a}[1],${n()})local ${b}=#${a}`; },
                // Math-heavy that looks like key computation
                () => { const a=v(),b=v(); return `local ${a}=math.floor(${n()}/(${Math.floor(Math.random()*50)+1}))local ${b}=bit32.lshift(${a},${Math.floor(Math.random()*4)+1})`; },
                // Fake task.delay
                () => `if false then task.delay(0,function()end)end`,
                // Nested function definition that mimics encryption
                () => { const a=v(),b=v(),c=v(); return `local ${a}=function(${b})local ${c}=0 for ${v()}=1,${Math.floor(Math.random()*8)+2} do ${c}=${c}+1 end return ${c} end`; },
            ];
            return patterns[Math.floor(Math.random() * patterns.length)]();
        }

        function generateHeavyJunk() {
            return generateJunk() + ' ';
        }

        function obfuscateVariables(code) {
            varMap = {};
            varCounter = 0;
            
            // Find and replace local variable declarations
            code = code.replace(/\blocal\s+([a-zA-Z_][a-zA-Z0-9_]*)/g, (match, varName) => {
                if (!LUAU_KEYWORDS.has(varName) && !ROBLOX_GLOBALS.has(varName)) {
                    if (!varMap[varName]) {
                        varMap[varName] = generateVarName();
                    }
                    return `local ${varMap[varName]}`;
                }
                return match;
            });
            
            // Replace variable usages
            for (const [oldName, newName] of Object.entries(varMap)) {
                const regex = new RegExp(`\\b${oldName}\\b`, 'g');
                code = code.replace(regex, newName);
            }
            
            return code;
        }

        function obfuscateStrings(code) {
            // Encrypt ALL strings - double quoted
            code = code.replace(/"([^"\\]*(?:\\.[^"\\]*)*)"/g, (match, str) => {
                if (str.length === 0) return match;
                return encryptString(str);
            });
            // Also encrypt single quoted strings
            code = code.replace(/'([^'\\]*(?:\\.[^'\\]*)*)'/g, (match, str) => {
                if (str.length === 0) return match;
                return encryptString(str);
            });
            return code;
        }

        // Obfuscate function calls - use hidden function table with XOR-encoded integer keys
        // DO NOT use encrypted string keys - they generate IIFEs with opaque predicates
        // that call functions like tostring(), creating circular nil references
        function obfuscateFunctionCalls(code) {
            const funcNames = ['print', 'warn', 'error'];
            const used = funcNames.filter(fn => new RegExp(`\\b${fn}\\s*\\(`).test(code));
            if (used.length === 0) return code;

            const tableVar = generateVarName();
            const xorKey = Math.floor(Math.random()*9000)+1000;
            // Use XOR-encoded integer keys - simple, reliable, no encryption IIFEs needed
            const entries = used.map((fn, idx) => `[bit32.bxor(${(idx+1)^xorKey},${xorKey})]=${fn}`);

            // Replace function calls with table lookups
            for (let idx = 0; idx < used.length; idx++) {
                const fn = used[idx];
                code = code.replace(new RegExp(`\\b${fn}\\s*\\(`, 'g'), `${tableVar}[bit32.bxor(${(idx+1)^xorKey},${xorKey})](`);
            }

            // Prepend function table
            code = `local ${tableVar}={${entries.join(',')}} ` + code;
            return code;
        }

        // Obfuscate numeric expressions like 1+1 (safe & minimal)
        function obfuscateNumbers(code) {
            const obfNum = (num) => {
                const n = parseInt(num, 10);
                if (!Number.isFinite(n)) return num;
                const k = Math.floor(Math.random() * 90) + 10;
                return `(${n + k}-${k})`;
            };
            // Only replace simple literal math to avoid breaking syntax
            return code.replace(/\b(\d+)\b\s*([+\-*/])\s*\b(\d+)\b/g, (m, a, op, b) => {
                return `(${obfNum(a)}${op}${obfNum(b)})`;
            });
        }

        function injectJunk(code) {
            const lines = code.split('\n');
            const result = [];
            const noInjectAfter = ['return', 'break', 'continue', 'until'];
            
            for (const line of lines) {
                result.push(line);
                const stripped = line.trim();
                if (stripped) {
                    const firstWord = stripped.split(/\s+/)[0] || '';
                    const isSafe = !noInjectAfter.includes(firstWord) &&
                                   !stripped.endsWith('then') &&
                                   !stripped.endsWith('do') &&
                                   !stripped.endsWith('else') &&
                                   !stripped.endsWith('function') &&
                                   !stripped.includes('function(');
                    if (isSafe && Math.random() < 0.12) {
                        result.push(generateJunk());
                    }
                }
            }
            
            return result.join('\n');
        }

        // ==================== CONTROL FLOW FLATTENING ====================
        // Wraps entire code in a state machine with fake branches
        // The real code is hidden among multiple junk blocks
        // Static analysis cannot determine which block executes without evaluating state
        function flattenControlFlow(code) {
            // Generate unique state values
            const usedStates = new Set();
            const genState = () => { let s; do { s = Math.floor(Math.random()*9000)+1000; } while(usedStates.has(s)); usedStates.add(s); return s; };
            
            const realState = genState();
            const exitState = genState();
            // 2-3 fake states
            const fakeCount = 2 + Math.floor(Math.random()*2);
            const fakeStates = [];
            for(let i=0;i<fakeCount;i++) fakeStates.push(genState());
            
            const vState = generateVarName();
            const vRun = generateVarName();
            
            // Compute initial state through opaque math so it can't be statically resolved
            const fk = Math.floor(Math.random()*9999);
            const initExpr = `bit32.bxor(${realState^fk},${fk})`;
            
            // Build all branches (shuffled order)
            const allBranches = [];
            
            // Real branch - contains the actual code
            allBranches.push({ state: realState, code: `${code} ${vState}=${exitState}`, isReal: true });
            
            // Exit branch
            allBranches.push({ state: exitState, code: `${vRun}=false`, isReal: false });
            
            // Fake branches with realistic-looking code
            for(let i=0;i<fakeStates.length;i++) {
                const nextFake = i < fakeStates.length-1 ? fakeStates[i+1] : exitState;
                allBranches.push({ state: fakeStates[i], code: `${generateJunk()} ${vState}=${nextFake}`, isReal: false });
            }
            
            // Shuffle the branches so real code position is random
            for(let i=allBranches.length-1;i>0;i--) {
                const j=Math.floor(Math.random()*(i+1));
                [allBranches[i],allBranches[j]]=[allBranches[j],allBranches[i]];
            }
            
            // Build while-loop state machine
            let result = `local ${vState}=${initExpr} local ${vRun}=true while ${vRun} do `;
            for(let i=0;i<allBranches.length;i++) {
                const prefix = i===0 ? 'if' : 'elseif';
                result += `${prefix} ${vState}==${allBranches[i].state} then ${allBranches[i].code} `;
            }
            result += `else ${vRun}=false end end`;
            
            return result;
        }

        // ==================== ENVIRONMENT VERIFICATION + ANTI-TAMPER ====================
        function generateAntiTamper() {
            const v=()=>generateVarName();
            const vHash=v(),vInp=v(),vSum=v(),vIdx=v();
            const vEnv=v(),vCheck=v();
            
            // Hash function
            let code = `local ${vHash}=function(${vInp})local ${vSum}=0 for ${vIdx}=1,#${vInp} do ${vSum}=bit32.band(bit32.bxor(bit32.lshift(${vSum},5)-${vSum}+string.byte(${vInp},${vIdx}),${vSum}),0x7FFFFFFF)end return ${vSum} end `;
            
            // Roblox environment verification
            code += `local ${vEnv}=type(game)=="userdata"and type(workspace)=="userdata"and type(Instance)=="table"or type(Instance)=="userdata"` + ' ';
            const vStr=v();
            code += `local ${vStr}=type(game)=="userdata"and"Roblox"or"" `;
            code += `local ${vCheck}=${vHash}(${vStr})` + ' ';
            
            // Light junk mixed in
            code += generateJunk();
            
            return code;
        }

        // ==================== VM BYTECODE PROTECTION ====================
        // Converts code to encrypted bytecode, wraps in custom VM decoder
        // Requires loadstring to execute
        function vmEncodeLayer(code) {
            // Generate encryption keys
            const seed = Math.floor(Math.random() * 0x7FFFFFFF);
            const key1 = Math.floor(Math.random() * 200) + 50;
            const key2 = Math.floor(Math.random() * 200) + 50;
            const key3 = Math.floor(Math.random() * 7) + 1;
            
            // Convert code to bytes and apply 3-layer encryption
            const bytes = [];
            for (let i = 0; i < code.length; i++) {
                let b = code.charCodeAt(i);
                // Layer 1: XOR with position-dependent key
                b = b ^ ((key1 + i * 7) % 256);
                // Layer 2: XOR with seed-derived key
                b = b ^ ((seed + i * 13) % 256);
                // Layer 3: rotate bits (simulate with math)
                b = ((b << key3) | (b >> (8 - key3))) & 0xFF;
                bytes.push(b);
            }
            
            // Split bytecode into chunks for the VM
            const chunkSize = 200 + Math.floor(Math.random() * 300);
            const chunks = [];
            for (let i = 0; i < bytes.length; i += chunkSize) {
                chunks.push(bytes.slice(i, i + chunkSize));
            }
            
            // Generate obfuscated variable names for VM
            const v = () => generateVarName();
            const vBC = v(), vSeed = v(), vK1 = v(), vK2 = v(), vK3 = v();
            const vDec = v(), vInp = v(), vOut = v(), vI = v(), vB = v();
            const vStr = v(), vChunks = v(), vResult = v(), vJ = v(), vC = v();
            const vExec = v(), vLoad = v();
            
            // Obfuscate the seed and keys with XOR
            const fk1 = Math.floor(Math.random() * 9999);
            const fk2 = Math.floor(Math.random() * 9999);
            const fk3 = Math.floor(Math.random() * 9999);
            const fkSeed = Math.floor(Math.random() * 0x7FFFFFFF);
            
            // Obfuscate ~25% of byte values, leave rest as plain numbers
            function obfByte(val) {
                if (Math.random() > 0.25) return `${val}`;
                const r = Math.random();
                if (r < 0.5) {
                    const a = val + Math.floor(Math.random() * 900) + 100;
                    return `(${a}-${a - val})`;
                } else {
                    const a = Math.floor(Math.random() * (val + 1));
                    return `(${a}+${val - a})`;
                }
            }
            
            // Build chunk arrays as Lua tables with obfuscated byte values
            const chunkStrs = chunks.map(chunk => `{${chunk.map(b => obfByte(b)).join(',')}}`);
            
            // Build the VM decoder in Lua
            let vm = '';
            const vPos = v();
            const vAll = v();
            const vPart = v();
            
            vm += `local ${v()}=type(game)=="userdata"and true or false `;
            vm += `local ${vSeed}=bit32.bxor(${seed ^ fkSeed},${fkSeed}) `;
            vm += `local ${vK1}=bit32.bxor(${key1 ^ fk1},${fk1}) `;
            vm += `local ${vK2}=bit32.bxor(${key2 ^ fk2},${fk2}) `;
            vm += `local ${vK3}=bit32.bxor(${key3 ^ fk3},${fk3}) `;
            vm += `local ${vChunks}={${chunkStrs.join(',')}} `;
            
            // Decode all chunks
            vm += `local ${vAll}={} `;
            vm += `local ${vPos}=0 `;
            vm += `for ${vI}=1,#${vChunks} do `;
            vm += `local ${vPart}=${vChunks}[${vI}] `;
            vm += `for ${vJ}=1,#${vPart} do `;
            vm += `local ${vB}=${vPart}[${vJ}] `;
            // Reverse layer 3: right-rotate by key3
            vm += `${vB}=bit32.band(bit32.bor(bit32.rshift(${vB},${vK3}),bit32.lshift(${vB},8-${vK3})),255) `;
            // Reverse layer 2
            vm += `${vB}=bit32.bxor(${vB},(${vSeed}+${vPos}*13)%256) `;
            // Reverse layer 1
            vm += `${vB}=bit32.bxor(${vB},(${vK1}+${vPos}*7)%256) `;
            vm += `${vAll}[#${vAll}+1]=string.char(${vB}) `;
            vm += `${vPos}=${vPos}+1 `;
            vm += `end end `;
            
            // Reconstruct and execute
            vm += `local ${vResult}=table.concat(${vAll}) `;
            
            // Anti-hook: verify loadstring exists
            const vType = v();
            vm += `local ${vLoad}=loadstring `;
            vm += `if type(${vLoad})~="function"then return end `;
            
            // Execute decoded code
            vm += `local ${vExec}=${vLoad}(${vResult}) `;
            vm += `if ${vExec} then ${vExec}() end`;
            
            return vm;
        }

        function compressToOneLine(code) {
            // Remove comments completely
            code = code.replace(/--\[\[[\s\S]*?\]\]/g, '');
            code = code.replace(/--[^\n]*/g, '');
            
            // Normalize whitespace
            code = code.replace(/\r\n/g, '\n');
            code = code.replace(/\n+/g, ' ');
            code = code.replace(/\s+/g, ' ');
            
            // Ensure keywords have spaces around them (single-pass regex)
            const kwPattern = /([^\s])(\b(?:local|function|end|if|then|else|elseif|for|in|do|while|repeat|until|return|and|or|not)\b)/g;
            const kwPattern2 = /(\b(?:local|function|end|if|then|else|elseif|for|in|do|while|repeat|until|return|and|or|not)\b)([^\s])/g;
            code = code.replace(kwPattern, '$1 $2');
            code = code.replace(kwPattern2, '$1 $2');
            
            // Collapse multiple spaces
            code = code.replace(/\s+/g, ' ');
            code = code.trim();
            
            // Add final junk to mask end of code
            code = code + ' local ' + generateVarName() + '=' + Math.floor(Math.random()*9999);
            
            return code;
        }

        // Called by button - checks captcha first
        async function obfuscate() {
            const input = document.getElementById('inputCode').value;
            if (!input.trim()) {
                showToast('Please enter some code!', 'warning');
                return;
            }
            
            // Check if captcha verification is needed
            if (!captchaVerified) {
                pendingObfuscation = true;
                showCaptchaModal();
                return;
            }
            
            // Reset captcha for next use
            captchaVerified = false;
            
            performObfuscation();
        }
        
        // ==================== LUA SYNTAX CHECKER ====================
        function checkLuaSyntax(code) {
            const errors = [];
            
            // Remove strings and comments to avoid false positives
            let cleaned = code;
            // Remove long strings [[...]]
            cleaned = cleaned.replace(/\[\[([\s\S]*?)\]\]/g, (m) => ' '.repeat(m.length));
            // Remove long comments --[[...]]
            cleaned = cleaned.replace(/--\[\[[\s\S]*?\]\]/g, (m) => ' '.repeat(m.length));
            // Remove single-line comments
            cleaned = cleaned.replace(/--[^\n]*/g, (m) => ' '.repeat(m.length));
            // Remove double-quoted strings
            cleaned = cleaned.replace(/"([^"\\]*(?:\\.[^"\\]*)*)"/g, (m) => ' '.repeat(m.length));
            // Remove single-quoted strings
            cleaned = cleaned.replace(/'([^'\\]*(?:\\.[^'\\]*)*)'/g, (m) => ' '.repeat(m.length));
            
            // Check balanced parentheses/brackets
            let parens = 0, brackets = 0, braces = 0;
            for (let i = 0; i < cleaned.length; i++) {
                const c = cleaned[i];
                if (c === '(') parens++;
                else if (c === ')') { parens--; if (parens < 0) { errors.push('多余的右括号 ")"'); break; } }
                else if (c === '[') brackets++;
                else if (c === ']') { brackets--; if (brackets < 0) { errors.push('多余的右括号 "]"'); break; } }
                else if (c === '{') braces++;
                else if (c === '}') { braces--; if (braces < 0) { errors.push('多余的右括号 "}"'); break; } }
            }
            if (parens > 0) errors.push(`缺少 ${parens} 个右括号 ")"`);
            if (brackets > 0) errors.push(`缺少 ${brackets} 个右括号 "]"`);
            if (braces > 0) errors.push(`缺少 ${braces} 个右括号 "}"`);
            
            // Check block matching: do/end, function/end, if/then/end, repeat/until
            const blockOpeners = (cleaned.match(/\b(function|do|if|repeat)\b/g) || []);
            const blockClosers = (cleaned.match(/\b(end|until)\b/g) || []);
            // Count each type
            let funcCount = 0, doCount = 0, ifCount = 0, repeatCount = 0;
            let endCount = 0, untilCount = 0;
            for (const w of blockOpeners) {
                if (w === 'function') funcCount++;
                else if (w === 'do') doCount++;
                else if (w === 'if') ifCount++;
                else if (w === 'repeat') repeatCount++;
            }
            for (const w of blockClosers) {
                if (w === 'end') endCount++;
                else if (w === 'until') untilCount++;
            }
            const expectedEnd = funcCount + doCount + ifCount;
            if (endCount < expectedEnd) errors.push(`缺少 ${expectedEnd - endCount} 个 "end"`);
            if (endCount > expectedEnd) errors.push(`多余 ${endCount - expectedEnd} 个 "end"`);
            if (untilCount < repeatCount) errors.push(`缺少 ${repeatCount - untilCount} 个 "until"`);
            if (untilCount > repeatCount) errors.push(`多余 ${untilCount - repeatCount} 个 "until"`);
            
            // Check if/then pairing
            const ifMatches = cleaned.match(/\bif\b/g) || [];
            const thenMatches = cleaned.match(/\bthen\b/g) || [];
            if (thenMatches.length < ifMatches.length) errors.push(`if 语句缺少 "then"`);
            
            // Check for unclosed strings in original code
            let inSingle = false, inDouble = false, escaped = false;
            for (let i = 0; i < code.length; i++) {
                const c = code[i];
                if (escaped) { escaped = false; continue; }
                if (c === '\\') { escaped = true; continue; }
                if (c === '"' && !inSingle) inDouble = !inDouble;
                else if (c === "'" && !inDouble) inSingle = !inSingle;
                // Reset on newline (Lua doesn't allow multiline unescaped strings)
                if (c === '\n' && (inSingle || inDouble)) {
                    errors.push('未闭合的字符串');
                    break;
                }
            }
            
            return errors;
        }

        // Actual obfuscation logic (called after captcha verified)
        async function performObfuscation() {
            const input = document.getElementById('inputCode').value;
            const btn = document.getElementById('obfuscateBtn');
            
            // Syntax check before obfuscation
            const syntaxErrors = checkLuaSyntax(input);
            if (syntaxErrors.length > 0) {
                showToast('语法错误: ' + syntaxErrors[0], 'error');
                return;
            }
            
            btn.disabled = true;
            showProgressOverlay();

            const stages = [
                'Scanning code structure...',
                'Mutating variable names...',
                'Encrypting string literals...',
                'Obfuscating function calls...',
                'Encoding numeric values...',
                'Injecting decoy code...',
                'Flattening control flow...',
                'Deploying anti-tamper...',
                'Compressing bytecode...',
                'Encoding to VM bytecode...',
                'Finalizing encryption...'
            ];

            let code = input;
            const usePassword = document.getElementById('enablePassword').checked;
            const password = document.getElementById('scriptPassword').value;
            
            if (usePassword && !password) {
                showToast('Please enter a password!', 'warning');
                hideProgressOverlay();
                btn.disabled = false;
                return;
            }
            
            try {
                for (let i = 0; i < stages.length; i++) {
                    const percent = Math.round((i / stages.length) * 100);
                    updateProgress(percent, stages[i]);
                    await sleep(80);
                    
                    switch(i) {
                        case 1: code = obfuscateVariables(code); break;
                        case 2: code = obfuscateStrings(code); break;
                        case 3: code = obfuscateFunctionCalls(code); break;
                        case 4: code = obfuscateNumbers(code); break;
                        case 5: code = injectJunk(code); break;
                        case 6: code = flattenControlFlow(code); break;
                        case 7: code = generateAntiTamper() + code; break;
                        case 8: code = compressToOneLine(code); break;
                        case 9: code = vmEncodeLayer(code); break;
                    }
                }
                
                // Add password encryption if enabled (embeds encrypted original for decryption)
                if (usePassword) {
                    updateProgress(95, 'Applying password encryption...');
                    await sleep(300);
                    // Encrypt original code and embed as comment (code still runs normally)
                    const encrypted = encryptWithPassword(input, password);
                    code = `--[[_SHDW_${encrypted}_END_]] ` + code;
                }
                
                updateProgress(100, 'Encryption complete!');
                await sleep(300);
                
                // Add version header to obfuscated output
const versionHeader = `--[[ SHADOW CIPHER v4.1.0 | ${new Date().toISOString().split('T')[0]} | luau.gkop.cc ]]\n`;
                code = versionHeader + code;

                document.getElementById('outputCode').value = code;
                
                // Update stats
                const origSize = new Blob([input]).size;
                const newSize = new Blob([code]).size;
                document.getElementById('statOriginal').textContent = origSize.toLocaleString();
                document.getElementById('statObfuscated').textContent = newSize.toLocaleString();
                document.getElementById('statChange').textContent = `+${((newSize/origSize - 1) * 100).toFixed(1)}%`;
                document.getElementById('statVars').textContent = Object.keys(varMap).length;

                showToast('Obfuscation complete!', 'success');
            } catch (e) {
                showToast('Error: ' + e.message, 'error');
            }
            
            hideProgressOverlay();
            btn.disabled = false;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        const toastIcons = {
            'success': '<svg viewBox="0 0 24 24" fill="none" stroke="#00ff88" stroke-width="2.5"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>',
            'error': '<svg viewBox="0 0 24 24" fill="none" stroke="#ff4444" stroke-width="2.5"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>',
            'warning': '<svg viewBox="0 0 24 24" fill="none" stroke="#ffaa00" stroke-width="2.5"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>',
            'copy': '<svg viewBox="0 0 24 24" fill="none" stroke="var(--neon-cyan)" stroke-width="2.5"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>',
            'download': '<svg viewBox="0 0 24 24" fill="none" stroke="var(--neon-purple)" stroke-width="2.5"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>'
        };
        
        function showToast(text, iconType = 'success') {
            const toast = document.getElementById('toast');
            document.getElementById('toastText').textContent = text;
            document.getElementById('toastIcon').innerHTML = toastIcons[iconType] || toastIcons['success'];
            toast.classList.add('active');
            setTimeout(() => toast.classList.remove('active'), 3000);
        }

        function copyOutput() {
            const output = document.getElementById('outputCode');
            if (!output.value) {
                showToast('No output to copy!', 'warning');
                return;
            }
            navigator.clipboard.writeText(output.value);
            showToast('Copied to clipboard!', 'copy');
        }

        function downloadOutput() {
            const output = document.getElementById('outputCode').value;
            if (!output) {
                showToast('No output to download!', 'warning');
                return;
            }
            const blob = new Blob([output], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'obfuscated_' + Date.now() + '.lua';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Downloaded!', 'download');
        }

        function clearInput() {
            document.getElementById('inputCode').value = '';
        }

        function loadSample() {
            document.getElementById('inputCode').value = `-- Sample Roblox Script
local player = game.Players.LocalPlayer
local character = player.Character

local function sayHello(name)
    print("Hello, " .. name .. "!")
    return true
end

local function calculateDamage(baseDamage, multiplier)
    local result = baseDamage * multiplier
    if result > 100 then
        result = 100
    end
    return result
end

local message = "Welcome to the game!"
print(message)

local damage = calculateDamage(25, 3)
sayHello("Player")`;
        }


        function togglePassword() {
            const enabled = document.getElementById('enablePassword').checked;
            const content = document.getElementById('passwordContent');
            const status = document.getElementById('pwdStatus');
            const strength = document.getElementById('pwdStrength');
            
            content.style.display = enabled ? 'block' : 'none';
            status.textContent = enabled ? 'ENABLED' : 'OPTIONAL';
            status.style.color = enabled ? 'var(--neon-pink)' : 'var(--neon-green)';
            
            if (!enabled) {
                document.getElementById('scriptPassword').value = '';
                strength.style.width = '0%';
            }
        }

        function togglePasswordVisibility() {
            const input = document.getElementById('scriptPassword');
            input.type = input.type === 'password' ? 'text' : 'password';
        }

        function updatePasswordStrength() {
            const pwd = document.getElementById('scriptPassword').value;
            const strength = document.getElementById('pwdStrength');
            let score = 0;
            if (pwd.length > 4) score += 25;
            if (pwd.length > 8) score += 25;
            if (/[A-Z]/.test(pwd)) score += 25;
            if (/[0-9]/.test(pwd)) score += 25;
            strength.style.width = score + '%';
        }

        function hashPassword(pwd) {
            // Simple hash for password verification
            let hash = 0;
            for (let i = 0; i < pwd.length; i++) {
                const char = pwd.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        function switchMode(mode) {
            const encryptMode = document.getElementById('encryptMode');
            const decryptMode = document.getElementById('decryptMode');
            const tabEncrypt = document.getElementById('tabEncrypt');
            const tabDecrypt = document.getElementById('tabDecrypt');
            
            if (mode === 'encrypt') {
                encryptMode.style.display = 'block';
                decryptMode.style.display = 'none';
                tabEncrypt.classList.add('active');
                tabDecrypt.classList.remove('active');
            } else {
                encryptMode.style.display = 'none';
                decryptMode.style.display = 'block';
                tabEncrypt.classList.remove('active');
                tabDecrypt.classList.add('active');
            }
        }

        function clearDecryptInput() {
            document.getElementById('decryptInput').value = '';
            document.getElementById('decryptOutput').value = '';
        }

        function copyDecrypted() {
            const output = document.getElementById('decryptOutput');
            if (!output.value) {
                showToast('No output to copy!', 'warning');
                return;
            }
            navigator.clipboard.writeText(output.value);
            showToast('Copied to clipboard!', 'copy');
        }

        function decryptCode() {
            const input = document.getElementById('decryptInput').value;
            const password = document.getElementById('scriptPassword').value;
            
            if (!input.trim()) {
                showToast('Please paste encrypted code!', 'warning');
                return;
            }
            
            if (!password) {
                showToast('Please enter the password!', 'warning');
                return;
            }
            
            try {
                // Find the encrypted marker and data
                const markerMatch = input.match(/_SHDW_([A-Za-z0-9+/=]+)_END_/);
                if (!markerMatch) {
                    showToast('No encrypted data found! This code may not be password-protected.', 'error');
                    return;
                }
                
                const encryptedData = markerMatch[1];
                const decrypted = decryptWithPassword(encryptedData, password);
                
                if (!decrypted || !decrypted.includes('local') && !decrypted.includes('function') && !decrypted.includes('print')) {
                    showToast('Wrong password!', 'error');
                    return;
                }
                
                document.getElementById('decryptOutput').value = decrypted;
                showToast('Decryption successful!', 'success');
            } catch (e) {
                showToast('Decryption failed: Wrong password or corrupted data', 'error');
            }
        }

        function encryptWithPassword(text, password) {
            // Convert text to byte array first (handles Unicode)
            const encoder = new TextEncoder();
            const textBytes = encoder.encode(text);
            const pwdBytes = encoder.encode(password);
            
            // XOR encryption
            const encrypted = new Uint8Array(textBytes.length);
            for (let i = 0; i < textBytes.length; i++) {
                encrypted[i] = textBytes[i] ^ pwdBytes[i % pwdBytes.length];
            }
            
            // Convert to Base64
            let binary = '';
            for (let i = 0; i < encrypted.length; i++) {
                binary += String.fromCharCode(encrypted[i]);
            }
            return btoa(binary);
        }

        function decryptWithPassword(encrypted, password) {
            try {
                // Base64 decode
                const binary = atob(encrypted);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                
                // XOR decrypt
                const encoder = new TextEncoder();
                const pwdBytes = encoder.encode(password);
                const decrypted = new Uint8Array(bytes.length);
                for (let i = 0; i < bytes.length; i++) {
                    decrypted[i] = bytes[i] ^ pwdBytes[i % pwdBytes.length];
                }
                
                // Convert back to string
                const decoder = new TextDecoder();
                return decoder.decode(decrypted);
            } catch (e) {
                return null;
            }
        }

        function generatePasswordProtection(password) {
            const hash = hashPassword(password);
            
            // All variable names - store them properly
            const vHashFunc = generateVarName();
            const vInput = generateVarName();
            const vSum = generateVarName();
            const vIdx = generateVarName();
            const vChar = generateVarName();
            const vXorKey = generateVarName();
            const vTargetHash = generateVarName();
            const vGui = generateVarName();
            const vFrame = generateVarName();
            const vLabel = generateVarName();
            const vTextBox = generateVarName();
            const vButton = generateVarName();
            const vUnlocked = generateVarName();
            const vInputHash = generateVarName();
            
            // Encrypt hash with XOR
            const xorKey = Math.floor(Math.random() * 9999) + 1000;
            const encHash = hash ^ xorKey;
            
            return `local ${vHashFunc}=function(${vInput}) local ${vSum}=0 for ${vIdx}=1,#${vInput} do local ${vChar}=${vInput}:byte(${vIdx}) ${vSum}=bit32.band(bit32.bxor(bit32.lshift(${vSum},5)-${vSum}+${vChar},${vSum}),0x7FFFFFFF) end return ${vSum} end local ${vXorKey}=${xorKey} local ${vTargetHash}=bit32.bxor(${encHash},${vXorKey}) local ${vGui}=Instance.new("ScreenGui") ${vGui}.Parent=game:GetService("CoreGui") ${vGui}.Name="_" local ${vFrame}=Instance.new("Frame",${vGui}) ${vFrame}.Size=UDim2.new(0,280,0,140) ${vFrame}.Position=UDim2.new(0.5,-140,0.5,-70) ${vFrame}.BackgroundColor3=Color3.fromRGB(25,25,35) ${vFrame}.BorderSizePixel=0 Instance.new("UICorner",${vFrame}).CornerRadius=UDim.new(0,12) local ${vLabel}=Instance.new("TextLabel",${vFrame}) ${vLabel}.Size=UDim2.new(1,0,0,35) ${vLabel}.BackgroundTransparency=1 ${vLabel}.Text="Password Required" ${vLabel}.TextColor3=Color3.fromRGB(255,100,180) ${vLabel}.TextSize=16 ${vLabel}.Font=Enum.Font.GothamBold local ${vTextBox}=Instance.new("TextBox",${vFrame}) ${vTextBox}.Size=UDim2.new(0.85,0,0,32) ${vTextBox}.Position=UDim2.new(0.075,0,0.32,0) ${vTextBox}.BackgroundColor3=Color3.fromRGB(40,40,55) ${vTextBox}.TextColor3=Color3.fromRGB(255,255,255) ${vTextBox}.PlaceholderText="Enter password..." ${vTextBox}.Text="" ${vTextBox}.TextSize=14 ${vTextBox}.Font=Enum.Font.Gotham ${vTextBox}.ClearTextOnFocus=false Instance.new("UICorner",${vTextBox}) local ${vButton}=Instance.new("TextButton",${vFrame}) ${vButton}.Size=UDim2.new(0.85,0,0,32) ${vButton}.Position=UDim2.new(0.075,0,0.65,0) ${vButton}.BackgroundColor3=Color3.fromRGB(140,50,140) ${vButton}.TextColor3=Color3.fromRGB(255,255,255) ${vButton}.Text="Unlock" ${vButton}.TextSize=14 ${vButton}.Font=Enum.Font.GothamBold Instance.new("UICorner",${vButton}) local ${vUnlocked}=false ${vButton}.MouseButton1Click:Connect(function() local ${vInputHash}=${vHashFunc}(${vTextBox}.Text) if ${vInputHash}==${vTargetHash} then ${vUnlocked}=true ${vGui}:Destroy() else ${vFrame}.BackgroundColor3=Color3.fromRGB(180,40,40) task.delay(0.3,function() ${vFrame}.BackgroundColor3=Color3.fromRGB(25,25,35) end) end end) repeat task.wait() until ${vUnlocked} `;
        }
    </script>
</body>
</html>
